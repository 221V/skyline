// Generated by CoffeeScript 1.6.2
(function() {
  (function($) {
    $.extend($.fn, {
      nextAll: function(s) {
        var $el, $els;

        $els = $();
        $el = this.next();
        while ($el.length) {
          if (typeof s === "undefined" || $el.is(s)) {
            $els = $els.add($el);
          }
          $el = $el.next();
        }
        return $els;
      },
      prevAll: function(s) {
        var $el, $els;

        $els = $();
        $el = this.prev();
        while ($el.length) {
          if (typeof s === "undefined" || $el.is(s)) {
            $els = $els.add($el);
          }
          $el = $el.prev();
        }
        return $els;
      },
      textboxlister: function(options) {
        var opts;

        opts = $.extend(true, $.TextboxLister.defaults, options);
        return this.each(function() {
          return new $.TextboxLister(this, opts);
        });
      },
      autocomplete: function(urlOrData, options) {
        var isUrl;

        isUrl = typeof urlOrData === "string";
        options = $.extend({}, $.Autocompleter.defaults, {
          url: (isUrl ? urlOrData : null),
          data: (isUrl ? null : urlOrData),
          max: (options && !options.scroll ? 10 : 150)
        }, options);
        options.highlight = options.highlight || function(value) {
          return value;
        };
        options.formatMatch = options.formatMatch || options.formatItem;
        return this.each(function() {
          return new $.Autocompleter(this, options);
        });
      },
      result: function(handler) {
        return this.on("result", handler);
      }
    });
    $.Autocompleter = function(input, options) {
      var $input, $spinner, KEY, autoFill, blockSubmit, cache, config, globalFailure, hasFocus, hideResults, hideResultsNow, lastKeyPressCode, lastWord, onChange, parse, previousValue, receiveData, request, select, selectCurrent, stopLoading, timeout, trimWords;

      selectCurrent = function() {
        var cursorAt, previousValue, progress, selected, seperator, v, wordAt, words;

        selected = select.selected();
        if (!selected) {
          return false;
        }
        v = selected.result;
        previousValue = v;
        if (options.multiple) {
          words = trimWords($input.val());
          if (words.length > 1) {
            seperator = options.multipleSeparator.length;
            cursorAt = $(input).selection().start;
            wordAt = void 0;
            progress = 0;
            $.each(words, function(i, word) {
              progress += word.length;
              if (cursorAt <= progress) {
                wordAt = i;
                return false;
              }
              return progress += seperator;
            });
            words[wordAt] = v;
            v = words.join(options.multipleSeparator);
          }
          v += options.multipleSeparator;
        }
        $input.val(v);
        hideResultsNow();
        $input.trigger("result", [selected.data, selected.value]);
        return true;
      };
      onChange = function(crap, skipPrevCheck) {
        var currentValue, previousValue;

        if (lastKeyPressCode === KEY.DEL) {
          select.hide();
          return;
        }
        currentValue = $input.val();
        if (!skipPrevCheck && currentValue === previousValue) {
          return;
        }
        previousValue = currentValue;
        currentValue = lastWord(currentValue);
        if (currentValue.length >= options.minChars) {
          $input.addClass(options.loadingClass);
          if (!options.matchCase) {
            currentValue = currentValue.toLowerCase();
          }
          return request(currentValue, receiveData, hideResultsNow);
        } else {
          stopLoading();
          return select.hide();
        }
      };
      trimWords = function(value) {
        if (!value) {
          return [""];
        }
        if (!options.multiple) {
          return [$.trim(value)];
        }
        return $.map(value.split(options.multipleSeparator), function(word) {
          if ($.trim(value).length) {
            return $.trim(word);
          } else {
            return null;
          }
        });
      };
      lastWord = function(value) {
        var cursorAt, words;

        if (!options.multiple) {
          return value;
        }
        words = trimWords(value);
        if (words.length === 1) {
          return words[0];
        }
        cursorAt = $(input).selection().start;
        if (cursorAt === value.length) {
          words = trimWords(value);
        } else {
          words = trimWords(value.replace(value.substring(cursorAt), ""));
        }
        return words[words.length - 1];
      };
      autoFill = function(q, sValue) {
        if (options.autoFill && (lastWord($input.val()).toLowerCase() === q.toLowerCase()) && lastKeyPressCode !== KEY.BACKSPACE) {
          $input.val($input.val() + sValue.substring(lastWord(previousValue).length));
          return $(input).selection(previousValue.length, previousValue.length + sValue.length);
        }
      };
      hideResults = function() {
        var timeout;

        clearTimeout(timeout);
        return timeout = setTimeout(hideResultsNow, 200);
      };
      hideResultsNow = function() {
        var wasVisible;

        wasVisible = select.visible();
        select.hide();
        clearTimeout(timeout);
        stopLoading();
        if (options.mustMatch) {
          return $input.search(function(result) {
            var words;

            if (!result) {
              if (options.multiple) {
                words = trimWords($input.val()).slice(0, -1);
                return $input.val(words.join(options.multipleSeparator) + (words.length ? options.multipleSeparator : ""));
              } else {
                $input.val("");
                return $input.trigger("result", null);
              }
            }
          });
        }
      };
      receiveData = function(q, data) {
        if (data && data.length && hasFocus) {
          stopLoading();
          select.display(data, q);
          autoFill(q, data[0].value);
          return select.show();
        } else {
          return hideResultsNow();
        }
      };
      request = function(term, success, failure) {
        var data, extraParams;

        if (!options.matchCase) {
          term = term.toLowerCase();
        }
        data = cache.load(term);
        if (data && data.length) {
          return success(term, data);
        } else if (options.autocomplete) {
          extraParams = {
            timestamp: +new Date()
          };
          $.each(options.extraParams, function(key, param) {
            return extraParams[key] = (typeof param === "function" ? param($input) : param);
          });
          if (options.autocomplete.postback) {
            return eval_(options.autocomplete.postback);
          }
        } else {
          select.emptyList();
          if (typeof globalFailure !== "undefined" && globalFailure !== null) {
            return globalFailure();
          } else {
            return failure(term);
          }
        }
      };
      parse = function(data) {
        var i, parsed, row;

        parsed = [];
        i = void 0;
        row = void 0;
        for (i in data) {
          row = data[i];
          parsed[parsed.length] = {
            data: row,
            value: row[0],
            result: options.formatResult && options.formatResult(row, row[0]) || row[0]
          };
        }
        return parsed;
      };
      stopLoading = function() {
        return $input.removeClass(options.loadingClass);
      };
      KEY = {
        UP: 38,
        DOWN: 40,
        DEL: 46,
        TAB: 9,
        RETURN: 13,
        ESC: 27,
        COMMA: 188,
        PAGEUP: 33,
        PAGEDOWN: 34,
        BACKSPACE: 8
      };
      globalFailure = null;
      if ((options.failure != null) && typeof options.failure === "function") {
        globalFailure = options.failure;
      }
      $input = $(input).attr("autocomplete", "off").addClass(options.inputClass);
      timeout = void 0;
      previousValue = "";
      cache = $.Autocompleter.Cache(options);
      hasFocus = 0;
      lastKeyPressCode = void 0;
      config = {
        mouseDownOnSelect: false
      };
      select = $.Autocompleter.Select(options, input, selectCurrent, config);
      blockSubmit = void 0;
      $input.wrap("<div style='position:relative; display:inline; white-space:nowrap'></div>");
      $spinner = $("<span class='textboxlister-autocomplete-spinner' />").insertAfter($input);
      window.setTimeout((function() {
        var margin;

        margin = parseInt($input.css("margin-right"), 10) || 0;
        return $spinner.css({
          "margin-left": -20 - margin
        });
      }), 0);
      $.browser.opera && $(input.form).bind("submit.autocomplete", function() {
        if (blockSubmit) {
          blockSubmit = false;
          return false;
        }
      });
      return $input.bind("keyup change", function(event) {
        hasFocus = 1;
        lastKeyPressCode = event.keyCode;
        switch (event.keyCode) {
          case KEY.UP:
            if (select.visible()) {
              event.preventDefault();
              return select.prev();
            } else {
              return onChange(0, true);
            }
            break;
          case KEY.DOWN:
            if (select.visible()) {
              event.preventDefault();
              return select.next();
            } else {
              return onChange(0, true);
            }
            break;
          case KEY.PAGEUP:
            if (select.visible()) {
              event.preventDefault();
              return select.pageUp();
            } else {
              return onChange(0, true);
            }
            break;
          case KEY.PAGEDOWN:
            if (select.visible()) {
              event.preventDefault();
              return select.pageDown();
            } else {
              return onChange(0, true);
            }
            break;
          case options.multiple && $.trim(options.multipleSeparator) === "," && KEY.COMMA:
          case KEY.TAB:
          case KEY.RETURN:
            if (selectCurrent()) {
              event.preventDefault();
              blockSubmit = true;
              return false;
            }
            break;
          case KEY.ESC:
            return select.hide();
          default:
            clearTimeout(timeout);
            return timeout = window.setTimeout(onChange, options.delay);
        }
      }).focus(function() {
        return hasFocus++;
      }).blur(function() {
        hasFocus = 0;
        if (!config.mouseDownOnSelect) {
          return hideResults();
        }
      }).click(function() {
        if (options.clickFire) {
          if (!select.visible()) {
            return onChange(0, true);
          }
        } else {
          if (hasFocus++ > 1 && !select.visible()) {
            return onChange(0, true);
          }
        }
      }).on("flushCache", function() {
        return cache.flush();
      }).on("setOptions", function() {
        $.extend(true, options, arguments_[1]);
        if ("data" in arguments_[1]) {
          return cache.populate();
        }
      }).on("unautocomplete", function() {
        select.unbind();
        $input.unbind();
        return $(input.form).unbind(".autocomplete");
      }).on("autocompleteData", function(e, res, term) {
        var data;

        data = options.parse && options.parse(res) || parse(res);
        return receiveData(term, data);
      });
    };
    $.Autocompleter.defaults = {
      inputClass: "textboxlister-autocomplete-input",
      resultsClass: "textboxlister-autocomplete-results",
      loadingClass: "textboxlister-autocomplete-loading",
      minChars: 1,
      delay: 10,
      matchCase: false,
      matchSubset: true,
      matchContains: false,
      cacheLength: 100,
      max: 1000,
      mustMatch: false,
      extraParams: {},
      selectFirst: true,
      formatItem: function(row) {
        return row[0];
      },
      formatMatch: null,
      autoFill: false,
      width: 0,
      multiple: false,
      multipleSeparator: " ",
      inputFocus: true,
      clickFire: false,
      inputFocus: true,
      clickFire: false,
      highlight: function(value, term) {
        return value.replace(new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + term.replace(/([\^\$\(\)\[\]\{\}\*\.\+\?\|\\])/g, "\\$1") + ")(?![^<>]*>)(?![^&;]+;)", "gi"), "<strong>$1</strong>");
      },
      scroll: true,
      scrollHeight: 180,
      scrollJumpPosition: true
    };
    $.Autocompleter.Cache = function(options) {
      var add, data, flush, length, matchSubset, populate;

      matchSubset = function(s, sub) {
        var i;

        if (!options.matchCase) {
          s = s.toLowerCase();
        }
        i = s.indexOf(sub);
        if (options.matchContains === "word") {
          i = s.toLowerCase().search("\\b" + sub.toLowerCase());
        }
        if (i === -1) {
          return false;
        }
        return i === 0 || options.matchContains;
      };
      add = function(q, value) {
        if (length > options.cacheLength) {
          flush();
        }
        if (!data[q]) {
          length++;
        }
        return data[q] = value;
      };
      populate = function() {
        var firstChar, i, nullData, ol, rawValue, row, stMatchSets, value;

        if (!options.data) {
          return false;
        }
        stMatchSets = {};
        nullData = 0;
        if (!options.url) {
          options.cacheLength = 1;
        }
        stMatchSets[""] = [];
        i = 0;
        ol = options.data.length;
        while (i < ol) {
          rawValue = options.data[i];
          rawValue = (typeof rawValue === "string" ? [rawValue] : rawValue);
          value = options.formatMatch(rawValue, i + 1, options.data.length);
          if (value === false) {
            continue;
          }
          firstChar = value.charAt(0).toLowerCase();
          if (!stMatchSets[firstChar]) {
            stMatchSets[firstChar] = [];
          }
          row = {
            value: value,
            data: rawValue,
            result: options.formatResult && options.formatResult(rawValue) || value
          };
          stMatchSets[firstChar].push(row);
          if (nullData++ < options.max) {
            stMatchSets[""].push(row);
          }
          i++;
        }
        return $.each(stMatchSets, function(i, value) {
          options.cacheLength++;
          return add(i, value);
        });
      };
      flush = function() {
        var data, length;

        data = {};
        return length = 0;
      };
      data = {};
      length = 0;
      setTimeout(populate, 25);
      return {
        flush: flush,
        add: add,
        populate: populate,
        load: function(q) {
          var c, csub, i, k;

          if (!options.cacheLength || !length) {
            return null;
          }
          if (!options.url && options.matchContains) {
            csub = [];
            for (k in data) {
              if (k.length > 0) {
                c = data[k];
                $.each(c, function(i, x) {
                  if (matchSubset(x.value, q)) {
                    return csub.push(x);
                  }
                });
              }
            }
            return csub;
          } else if (data[q]) {
            return data[q];
          } else if (options.matchSubset) {
            i = q.length - 1;
            while (i >= options.minChars) {
              c = data[q.substr(0, i)];
              if (c) {
                csub = [];
                $.each(c, function(i, x) {
                  if (matchSubset(x.value, q)) {
                    return csub[csub.length] = x;
                  }
                });
                return csub;
              }
              i--;
            }
          }
          return null;
        }
      };
    };
    $.Autocompleter.Select = function(options, input, select, config) {
      var CLASSES, active, b, data, element, fillList, init, limitNumberOfItems, list, listItems, movePosition, moveSelect, needsInit, target, term;

      init = function() {
        var element, list, needsInit;

        if (!needsInit) {
          return;
        }
        element = $("<div/>").hide().addClass(options.resultsClass).appendTo(b);
        list = $("<ul/>").mouseover(function(event) {
          var active;

          if (target(event).nodeName && target(event).nodeName.toUpperCase() === "LI") {
            active = $("li", list).removeClass(CLASSES.ACTIVE).index(target(event));
            return $(target(event)).addClass(CLASSES.ACTIVE);
          }
        }).click(function(event) {
          $(target(event)).addClass(CLASSES.ACTIVE);
          select();
          if (options.inputFocus) {
            input.focus();
          }
          return false;
        }).mousedown(function() {
          return config.mouseDownOnSelect = true;
        }).mouseup(function() {
          return config.mouseDownOnSelect = false;
        });
        $(element).append(list);
        if (options.width > 0) {
          element.css("width", options.width);
        }
        return needsInit = false;
      };
      target = function(event) {
        var element;

        element = event.target;
        while (element && element.tagName !== "LI") {
          element = element.parentNode;
        }
        if (!element) {
          return [];
        }
        return element;
      };
      moveSelect = function(step) {
        var activeItem, offset;

        listItems.slice(active, active + 1).removeClass(CLASSES.ACTIVE);
        movePosition(step);
        activeItem = listItems.slice(active, active + 1).addClass(CLASSES.ACTIVE);
        if (options.scroll) {
          offset = 0;
          listItems.slice(0, active).each(function() {
            return offset += this.offsetHeight;
          });
          if ((offset + activeItem[0].offsetHeight - list.scrollTop()) > list[0].clientHeight) {
            return list.scrollTop(offset + activeItem[0].offsetHeight - list.innerHeight());
          } else {
            if (offset < list.scrollTop()) {
              return list.scrollTop(offset);
            }
          }
        }
      };
      movePosition = function(step) {
        var active;

        if (options.scrollJumpPosition || (!options.scrollJumpPosition && !((step < 0 && active === 0) || (step > 0 && active === listItems.size() - 1)))) {
          active += step;
          if (active < 0) {
            return active = listItems.size() - 1;
          } else {
            if (active >= listItems.size()) {
              return active = 0;
            }
          }
        }
      };
      limitNumberOfItems = function(available) {
        if (options.max && options.max < available) {
          return options.max;
        } else {
          return available;
        }
      };
      fillList = function() {
        var active, formatted, i, li, listItems, max;

        list.empty();
        max = limitNumberOfItems(data.length);
        i = 0;
        while (i < max) {
          if (!data[i]) {
            continue;
          }
          formatted = options.formatItem(data[i].data, i + 1, max, data[i].value, term);
          if (formatted === false) {
            continue;
          }
          li = $("<li/>").html(options.highlight(formatted, term)).addClass((i % 2 === 0 ? "textboxlister-autocomplete-even" : "textboxlister-autocomplete-odd")).appendTo(list)[0];
          $(li).attr("data-textboxlister-autocomplete", JSON.stringify(data[i]));
          i++;
        }
        listItems = list.find("li");
        if (options.selectFirst) {
          listItems.slice(0, 1).addClass(CLASSES.ACTIVE);
          active = 0;
        }
        if ($.fn.bgiframe) {
          return list.bgiframe();
        }
      };
      CLASSES = {
        ACTIVE: "textboxlister-autocomplete-over"
      };
      b = $(input).parent().parent();
      listItems = void 0;
      active = -1;
      data = void 0;
      term = "";
      needsInit = true;
      element = void 0;
      list = void 0;
      return {
        display: function(d, q) {
          init();
          data = d;
          term = q;
          return fillList();
        },
        next: function() {
          return moveSelect(1);
        },
        prev: function() {
          return moveSelect(-1);
        },
        pageUp: function() {
          if (active !== 0 && active - 8 < 0) {
            return moveSelect(-active);
          } else {
            return moveSelect(-8);
          }
        },
        pageDown: function() {
          if (active !== listItems.size() - 1 && active + 8 > listItems.size()) {
            return moveSelect(listItems.size() - 1 - active);
          } else {
            return moveSelect(8);
          }
        },
        hide: function() {
          element && element.hide();
          listItems && listItems.removeClass(CLASSES.ACTIVE);
          return active = -1;
        },
        visible: function() {
          return element && element.css("display") !== "none";
        },
        current: function() {
          return this.visible() && (listItems.filter("." + CLASSES.ACTIVE)[0] || options.selectFirst && listItems[0]);
        },
        show: function() {
          var listHeight, scrollbarsVisible;

          element.css({
            width: $(input).parent().parent().width() - 2,
            top: $(input).parent().parent().height() + 1,
            left: 0
          }).show();
          if (options.scroll) {
            list.scrollTop(0);
            list.css({
              maxHeight: options.scrollHeight,
              overflow: "auto"
            });
            if ($.browser.msie && typeof document.body.style.maxHeight === "undefined") {
              listHeight = 0;
              listItems.each(function() {
                return listHeight += this.offsetHeight;
              });
              scrollbarsVisible = listHeight > options.scrollHeight;
              list.css("height", (scrollbarsVisible ? options.scrollHeight : listHeight));
              if (!scrollbarsVisible) {
                return listItems.width(list.width() - parseInt(listItems.css("padding-left")) - parseInt(listItems.css("padding-right")));
              }
            }
          }
        },
        selected: function() {
          var selected;

          selected = listItems && listItems.filter("." + CLASSES.ACTIVE).removeClass(CLASSES.ACTIVE);
          data = selected;
          if ($(selected).attr("data-textboxlister-autocomplete")) {
            data = JSON.parse($(selected).attr("data-textboxlister-autocomplete"));
          }
          return selected.length && data;
        },
        emptyList: function() {
          return list && list.empty();
        },
        unbind: function() {
          return element && element.remove();
        }
      };
    };
    $.fn.selection = function(start, end) {
      var caretAt, field, orig, range, teststring, textLength;

      if (start !== undefined) {
        return this.each(function() {
          var selRange;

          if (this.createTextRange) {
            selRange = this.createTextRange();
            if (end === undefined || start === end) {
              selRange.move("character", start);
              return selRange.select();
            } else {
              selRange.collapse(true);
              selRange.moveStart("character", start);
              selRange.moveEnd("character", end);
              return selRange.select();
            }
          } else if (this.setSelectionRange) {
            return this.setSelectionRange(start, end);
          } else if (this.selectionStart) {
            this.selectionStart = start;
            return this.selectionEnd = end;
          }
        });
      }
      field = this[0];
      if (field.createTextRange) {
        range = document.selection.createRange();
        orig = field.value;
        teststring = "<->";
        textLength = range.text.length;
        range.text = teststring;
        caretAt = field.value.indexOf(teststring);
        field.value = orig;
        this.selection(caretAt, caretAt + textLength);
        return {
          start: caretAt,
          end: caretAt + textLength
        };
      } else if (field.selectionStart !== undefined) {
        return {
          start: field.selectionStart,
          end: field.selectionEnd
        };
      }
    };
    $.TextboxLister = function(elem, opts) {
      var cursor, dir, focused, self;

      dir = {
        self: 0,
        prev: 1,
        next: 2
      };
      self = this;
      cursor = void 0;
      focused = false;
      self.input = $(elem);
      elem.textboxLister = self;
      self.opts = opts;
      if (!self.opts.inputName) {
        self.opts.inputName = self.input.attr("name");
      }
      self.container = self.input.wrap("<div class=" + self.opts.listValuesContainerClass + "></div>");
      self.mainContainer = self.input.parent().wrap("<div class=" + self.opts.containerClass + "></div>");
      self.mainContainer.focusin(function() {
        return focused = true;
      });
      $(document).focusin(function(e) {
        return focused = $(e.target).closest(self.mainContainer).length !== 0;
      });
      if (self.opts.clearControl) {
        $(self.opts.clearControl).click(function() {
          self.clear();
          this.blur();
          return false;
        });
      }
      if (self.opts.resetControl) {
        $(self.opts.resetControl).click(function() {
          self.reset();
          this.blur();
          return false;
        });
      }
      if (self.opts.autocomplete) {
        self.input.attr("autocomplete", "off").autocomplete(self.opts.autocomplete, self.opts).result(function(event, data, value) {
          return self.select(data[0]);
        });
      } else {
        self.input.keypress(function(event) {
          var val;

          if (event.keyCode === 13) {
            val = self.input.val();
            if (val) {
              self.select(val);
              event.preventDefault();
              return false;
            }
          }
        });
      }
      $(document).keydown(function(e) {
        var eStop, el, val;

        if (!focused) {
          return;
        }
        if ($("." + self.opts.containerClass + " *:focus").length === 0 && $("." + self.opts.listValueSelectedClass).length === 0) {
          return;
        }
        if ($(self.input).is(":focus") && self.input.val().length > 0) {
          return;
        }
        eStop = function() {
          e.stopPropagation();
          return e.preventDefault();
        };
        switch (e.keyCode) {
          case 8:
            if (self.input.val().length === 0) {
              eStop();
              if (self.cursor) {
                el = self.cursor;
                if ($(self.cursor).prev("span." + self.opts.listValueClass).is("span")) {
                  self.focusTag(self.cursor, "prev");
                } else {
                  self.input.focus();
                }
                self.deselect(el.find("input").val());
              } else {
                self.focusTag(self.input.prev("span." + self.opts.listValueClass), "self");
                self.input.blur();
              }
            }
            break;
          case self.opts.keys.prev:
            eStop();
            if (self.cursor) {
              return self.focusTag(self.cursor, "prev");
            } else {
              self.focusTag(self.input.prev("span." + self.opts.listValueClass), "self");
              return self.input.blur();
            }
            break;
          case self.opts.keys.next:
            eStop();
            return self.focusTag(self.cursor, "next");
          case self.opts.keys.del:
            eStop();
            val = $(self.cursor).find("input").val();
            if ($(self.cursor).next("span." + self.opts.listValueClass).is("span")) {
              self.focusTag(self.cursor, "next");
            } else if ($(self.cursor).prev("span." + self.opts.listValueClass).is("span")) {
              self.focusTag(self.cursor, "prev");
            } else {
              self.input.focus();
            }
            return self.input.trigger("DeleteValue", val);
        }
      });
      self.input.bind("SpanClick", function(e, val) {
        return self.focusTag(val, "self");
      });
      self.input.bind("SelectedValue", function(e, val) {
        var gap, i, il, offset, span, valuesContainer, width;

        valuesContainer = $(self.input).parent().parent();
        il = valuesContainer.width() - 20;
        span = $(self.input).prevAll("span");
        i = void 0;
        offset = 0;
        i = 0;
        while (i < span.length) {
          offset = offset + $(span[i]).width() + 5;
          gap = il - offset;
          if (gap < 40) {
            offset = 0;
            i--;
          }
          i++;
        }
        width = il - offset;
        return $(self.input).css({
          width: width
        });
      });
      self.input.bind("AddValue", function(e, val) {
        if (val) {
          return self.select(val);
        }
      });
      self.input.bind("DeleteValue", function(e, val) {
        if (val) {
          self.deselect([val]);
          if (!self.cursor) {
            return $(self.input).focus();
          }
        }
      });
      self.input.bind("Reset", function(e) {
        return self.reset();
      });
      self.input.bind("Clear", function(e) {
        return self.clear();
      });
      self.currentValues = [];
      self.titleOfValue = [];
      if (self.input.val()) {
        self.select(self.input.val().split(/\s*,\s*/).sort(), true);
      }
      self.initialValues = self.currentValues.slice();
      self.input.show();
      return this;
    };
    $.TextboxLister.prototype.focusTag = function(span, direction) {
      var next, prev, self;

      self = this;
      if (direction === "self") {
        $("." + self.opts.listValueSelectedClass).removeClass(self.opts.listValueSelectedClass);
        self.cursor = span;
        return $(span).addClass(self.opts.listValueSelectedClass);
      } else if (direction === "prev") {
        prev = $(span).prev("span." + self.opts.listValueClass);
        if (prev.is("span")) {
          $(self.cursor).removeClass(self.opts.listValueSelectedClass);
          prev.addClass(self.opts.listValueSelectedClass);
          return self.cursor = prev;
        }
      } else if (direction === "next") {
        next = $(span).next("span." + self.opts.listValueClass);
        if (next.is("span")) {
          $(self.cursor).removeClass(self.opts.listValueSelectedClass);
          next.addClass(self.opts.listValueSelectedClass);
          return self.cursor = next;
        } else {
          $(self.cursor).removeClass(self.opts.listValueSelectedClass);
          self.cursor = null;
          return self.input.focus();
        }
      }
    };
    $.TextboxLister.prototype.clear = function() {
      var self;

      self = this;
      self.container.parent().find("." + self.opts.listValueClass).remove();
      self.currentValues = [];
      self.titleOfValue = [];
      if (typeof self.opts.onClear === "function") {
        return self.opts.onClear(self);
      }
    };
    $.TextboxLister.prototype.reset = function() {
      var self;

      self = this;
      self.clear();
      self.select(self.initialValues);
      if (typeof self.opts.onReset === "function") {
        return self.opts.onReset(self);
      }
    };
    $.TextboxLister.prototype.select = function(values, suppressCallback) {
      var className, close, currentVal, cursorVal, found, i, input, j, self, sp, title, val;

      self = this;
      i = void 0;
      j = void 0;
      val = void 0;
      title = void 0;
      found = void 0;
      currentVal = void 0;
      input = void 0;
      close = void 0;
      className = void 0;
      if (typeof values === "object") {
        values = values.join(",");
      }
      if (typeof values !== "undefined" && typeof values !== "null") {
        values = values.split(/\s*,\s*/).sort();
      } else {
        values = "";
      }
      i = 0;
      while (i < values.length) {
        val = values[i];
        found = false;
        if (!val) {
          continue;
        }
        title = val;
        if (val.match(/^(.*)=(.*)$/)) {
          values[i] = val = RegExp.$1;
          self.titleOfValue["_" + val] = RegExp.$2;
        }
        i++;
      }
      if (self.currentValues.length > 0) {
        i = 0;
        while (i < values.length) {
          val = values[i];
          found = false;
          if (!val) {
            continue;
          }
          j = 0;
          while (j < self.currentValues.length) {
            currentVal = self.currentValues[j];
            if (currentVal === val) {
              found = true;
              break;
            }
            j++;
          }
          if (!found) {
            self.currentValues.push(val);
          }
          i++;
        }
      } else {
        self.currentValues = [];
        i = 0;
        while (i < values.length) {
          val = values[i];
          if (val) {
            self.currentValues.push(val);
          }
          i++;
        }
      }
      if (self.opts.doSort) {
        self.currentValues = self.currentValues.sort();
      }
      cursorVal = $(self.cursor).find("input").val();
      self.cursor = null;
      self.container.parent().find("." + self.opts.listValueClass).remove();
      i = self.currentValues.length - 1;
      while (i >= 0) {
        val = self.currentValues[i];
        if (!val) {
          continue;
        }
        title = $("<a href='#'>" + (self.titleOfValue["_" + val] || val) + "</a>");
        title.addClass(self.opts.titleClass);
        className = "tag_" + val;
        input = "<input type='hidden' class='" + self.opts.inputName + "' name='" + self.opts.inputName + "' value='" + val + "' title='" + self.titleOfValue["_" + val] + "' />";
        close = $("<a href='#' title='remove " + (self.titleOfValue["_" + val] || val) + "'></a>").addClass(self.opts.closeClass).click(function(e) {
          e.preventDefault();
          self.input.trigger("DeleteValue", $(this).parent().find("input").val());
          return false;
        });
        sp = $("<span tabindex='0'></span>");
        sp.addClass(self.opts.listValueClass + " " + className).append(input).append(title).append(close).prependTo($(self.container).parent());
        if (val === cursorVal) {
          sp.addClass(self.opts.listValueSelectedClass);
          self.cursor = sp;
        }
        sp.click(function(e) {
          e.preventDefault();
          e.stopPropagation();
          return self.input.trigger("SpanClick", $(this));
        });
        i--;
      }
      self.input.val("");
      if (!suppressCallback && typeof self.opts.onSelect === "function") {
        self.opts.onSelect(self);
      }
      return self.input.trigger("SelectedValue", values);
    };
    $.TextboxLister.prototype.deselect = function(values) {
      var currentVal, found, i, j, newValues, self, val;

      self = this;
      newValues = [];
      i = void 0;
      j = void 0;
      currentVal = void 0;
      found = void 0;
      val = void 0;
      if (typeof values === "object") {
        values = values.join(",");
      }
      values = values.split(/\s*,\s*/);
      if (!values.length) {
        return;
      }
      i = 0;
      while (i < self.currentValues.length) {
        currentVal = self.currentValues[i];
        if (!currentVal) {
          continue;
        }
        found = false;
        j = 0;
        while (j < values.length) {
          val = values[j];
          if (val && currentVal === val) {
            found = true;
            break;
          }
          j++;
        }
        if (!found && currentVal) {
          newValues.push(currentVal);
        }
        i++;
      }
      self.currentValues = newValues;
      if (typeof self.opts.onDeselect === "function") {
        self.opts.onDeselect(self);
      }
      return self.select(newValues, true);
    };
    return $.TextboxLister.defaults = {
      containerClass: "textboxlister",
      listValuesContainerClass: "textboxlister-values",
      listValueContainerClass: "textboxlister-value-container",
      listValueClass: "textboxlister-value",
      listValueSelectedClass: "textboxlister-value-selected",
      titleClass: "textboxlister-value-title",
      closeClass: "textboxlister-close",
      keys: {
        prev: 37,
        next: 39,
        del: 46
      },
      doSort: false,
      inputName: undefined,
      resetControl: undefined,
      clearControl: undefined,
      autocomplete: undefined,
      onClear: undefined,
      onReset: undefined,
      onSelect: undefined,
      onDeselect: undefined,
      selectFirst: false,
      autoFill: false,
      matchCase: false,
      matchContains: false,
      matchSubset: true
    };
  })(window.jQuery || window.Zepto);

}).call(this);
